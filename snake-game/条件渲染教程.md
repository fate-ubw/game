# 🎓 Vue 条件渲染教程 - 单页面多状态

## 问题：为什么一个 template 可以实现"3个页面"？

答案：这不是真的 3 个页面，而是**一个页面的 3 个状态**，通过 Vue 的**条件渲染**来控制显示。

---

## 📚 核心概念：条件渲染 (v-if)

Vue 的 `v-if` 指令可以根据条件**动态显示或隐藏**元素。

### 基础示例

```vue
<template>
  <div>
    <!-- 只有当 isVisible 为 true 时才显示 -->
    <p v-if="isVisible">我现在可见</p>
    
    <!-- 只有当 isVisible 为 false 时才显示 -->
    <p v-else>我现在不可见</p>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const isVisible = ref(true)  // 响应式变量
</script>
```

---

## 🎮 贪吃蛇游戏的 3 个"页面"

让我们看看游戏是如何通过**状态变量**控制不同"页面"的：

### 1️⃣ 状态变量（控制器）

```javascript
// 在 <script setup> 中定义的状态变量
const gameStarted = ref(false)  // 游戏是否已开始
const gameOver = ref(false)     // 游戏是否结束
```

### 2️⃣ 三个"页面"状态

| 状态 | gameStarted | gameOver | 显示内容 |
|------|-------------|----------|----------|
| **开始页面** | `false` | `false` | 显示"开始游戏"按钮 |
| **游戏进行中** | `true` | `false` | 显示游戏画布（可玩） |
| **游戏结束页面** | `true` | `true` | 显示"重新开始"按钮 |

### 3️⃣ Template 中的条件渲染

```vue
<template>
  <div class="game-container">
    <!-- 页面1: 开始页面 -->
    <!-- 条件：游戏还没开始 -->
    <div v-if="!gameStarted" class="start-screen">
      <h2>准备开始</h2>
      <button @click="startGame">开始游戏</button>
    </div>

    <!-- 页面3: 游戏结束页面 -->
    <!-- 条件：游戏已结束 -->
    <div v-if="gameOver" class="game-over">
      <h2>游戏结束!</h2>
      <button @click="restartGame">重新开始</button>
    </div>

    <!-- 页面2: 游戏画布（一直存在，但可能被遮挡） -->
    <canvas ref="gameCanvas"></canvas>
  </div>
</template>
```

---

## 🔄 状态转换流程

让我用图示说明状态如何变化：

```
初始状态
gameStarted = false
gameOver = false
         ↓
    [点击"开始游戏"]
         ↓
游戏进行中
gameStarted = true
gameOver = false
         ↓
    [蛇撞墙或撞自己]
         ↓
游戏结束
gameStarted = true
gameOver = true
         ↓
    [点击"重新开始"]
         ↓
游戏进行中
gameStarted = true
gameOver = false
```

---

## 💡 实际代码解析

### 开始游戏函数

```javascript
const startGame = () => {
  gameStarted.value = true   // ← 改变状态：隐藏开始页面
  gameOver.value = false     // ← 确保不显示结束页面
  // ... 初始化游戏数据
  gameLoop = setInterval(update, gameSpeed.value)  // 开始游戏循环
}
```

**效果**：
- `gameStarted` 变为 `true` → `v-if="!gameStarted"` 变为 `false` → 开始页面消失 ✨
- 游戏画布一直在那里，现在可以看到了

### 结束游戏函数

```javascript
const endGame = () => {
  gameOver.value = true      // ← 改变状态：显示结束页面
  clearInterval(gameLoop)    // 停止游戏循环
}
```

**效果**：
- `gameOver` 变为 `true` → `v-if="gameOver"` 变为 `true` → 结束页面出现 ✨

### 重新开始函数

```javascript
const restartGame = () => {
  startGame()  // 重新调用开始游戏（会重置所有状态）
}
```

---

## 🎨 CSS 布局技巧

注意到开始页面和结束页面使用了 `position: absolute`：

```css
.start-screen,
.game-over {
  position: absolute;  /* 绝对定位，覆盖在画布上方 */
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(26, 26, 46, 0.95);  /* 半透明背景 */
  z-index: 10;  /* 确保在画布上方 */
}
```

这样做的好处：
- 画布一直在后面渲染（性能优化）
- 开始/结束页面像"遮罩层"一样覆盖在上面
- 通过 `v-if` 控制遮罩层的显示/隐藏

---

## 🔍 完整的状态管理示例

让我创建一个简化版本来演示：

```vue
<template>
  <div>
    <!-- 状态 1: 欢迎页面 -->
    <div v-if="currentPage === 'welcome'">
      <h1>欢迎！</h1>
      <button @click="currentPage = 'game'">开始</button>
    </div>

    <!-- 状态 2: 游戏页面 -->
    <div v-if="currentPage === 'game'">
      <h1>游戏中...</h1>
      <button @click="currentPage = 'end'">结束</button>
    </div>

    <!-- 状态 3: 结束页面 -->
    <div v-if="currentPage === 'end'">
      <h1>游戏结束</h1>
      <button @click="currentPage = 'welcome'">返回</button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const currentPage = ref('welcome')  // 当前页面状态
</script>
```

**工作原理**：
1. `currentPage` 的值决定显示哪个 `<div>`
2. 点击按钮改变 `currentPage` 的值
3. Vue 自动重新渲染，只显示匹配条件的 `<div>`

---

## 🆚 对比：多页面 vs 单页面应用

### 传统多页面应用（MPA）
```
page1.html  ──跳转──>  page2.html  ──跳转──>  page3.html
   ↑                                              ↓
   └──────────────────── 跳转 ────────────────────┘
```
- 每次跳转都要重新加载整个页面
- 浏览器发送新的 HTTP 请求
- 页面会闪烁、重新加载资源

### 单页面应用（SPA）- 我们的方案
```
同一个 HTML 文件
   ↓
显示状态 1  ──切换──>  显示状态 2  ──切换──>  显示状态 3
   ↑                                              ↓
   └──────────────────── 切换 ────────────────────┘
```
- 只加载一次 HTML
- 通过 JavaScript 改变状态
- 无刷新、流畅的用户体验

---

## 🎯 贪吃蛇游戏的状态逻辑总结

```vue
<template>
  <!-- 永远存在的容器 -->
  <div class="game-container">
    
    <!-- 条件1: 未开始 → 显示开始页面 -->
    <div v-if="!gameStarted" class="start-screen">
      <!-- 开始页面内容 -->
    </div>

    <!-- 条件2: 已结束 → 显示结束页面 -->
    <div v-if="gameOver" class="game-over">
      <!-- 结束页面内容 -->
    </div>

    <!-- 永远存在的画布（可能被上面两个遮挡） -->
    <canvas ref="gameCanvas"></canvas>
  </div>
</template>

<script setup>
// 状态控制变量
const gameStarted = ref(false)  // false = 显示开始页面
const gameOver = ref(false)     // true = 显示结束页面

// 改变状态的函数
const startGame = () => {
  gameStarted.value = true   // 隐藏开始页面
  gameOver.value = false     // 确保不显示结束页面
}

const endGame = () => {
  gameOver.value = true      // 显示结束页面
}

const restartGame = () => {
  startGame()                // 重置到游戏进行状态
}
</script>
```

---

## 🧪 动手实验

你可以在浏览器的开发者工具中观察状态变化：

1. 打开游戏页面: http://localhost:5173/game/
2. 按 F12 打开开发者工具
3. 在 Console 中输入：
   ```javascript
   // 查看当前状态（需要安装 Vue DevTools）
   // 或者直接在代码中添加 console.log
   ```

4. 观察点击按钮时 DOM 的变化：
   - 点击"开始游戏" → `.start-screen` 元素从 DOM 中移除
   - 游戏结束 → `.game-over` 元素添加到 DOM

---

## 📊 状态变化时间线

```
时间轴：  0s          5s          10s         15s
         ↓           ↓           ↓           ↓
页面：   开始页面  →  游戏中  →  游戏中  →  结束页面
         
状态：   gameStarted: false    true       true       true
         gameOver:    false    false      false      true
         
显示：   开始按钮     画布       画布      结束按钮
         难度选择              (蛇在动)   最终分数
```

---

## 💡 为什么这样设计？

### 优点：
1. **性能好**: 不需要重新加载页面
2. **状态保持**: 游戏数据（分数、蛇的位置）不会丢失
3. **动画流畅**: 可以添加淡入淡出等过渡效果
4. **代码集中**: 所有逻辑在一个组件中，易于维护

### 如果想要真正的多页面：

```
game/
├── start.html      # 开始页面
├── game.html       # 游戏页面
└── gameover.html   # 结束页面
```

但这样会有问题：
- ❌ 页面跳转时游戏状态丢失
- ❌ 需要用 URL 参数或 localStorage 传递分数
- ❌ 页面切换会有闪烁
- ❌ 代码重复（每个页面都要引入相同的 CSS/JS）

---

## 🎨 添加过渡动画（可选）

如果想让状态切换更平滑，可以使用 Vue 的 `<Transition>`：

```vue
<template>
  <div class="game-container">
    <Transition name="fade">
      <div v-if="!gameStarted" class="start-screen">
        <!-- 开始页面 -->
      </div>
    </Transition>

    <Transition name="fade">
      <div v-if="gameOver" class="game-over">
        <!-- 结束页面 -->
      </div>
    </Transition>

    <canvas ref="gameCanvas"></canvas>
  </div>
</template>

<style>
.fade-enter-active, .fade-leave-active {
  transition: opacity 0.3s;
}
.fade-enter-from, .fade-leave-to {
  opacity: 0;
}
</style>
```

---

## 🔧 实践练习

想要更好地理解？试试修改代码：

### 练习 1: 添加一个"暂停页面"

```vue
<template>
  <!-- 在 game-container 中添加 -->
  <div v-if="isPaused && gameStarted && !gameOver" class="pause-screen">
    <h2>游戏暂停</h2>
    <button @click="togglePause">继续游戏</button>
  </div>
</template>

<style>
.pause-screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
  z-index: 10;
}
</style>
```

### 练习 2: 添加调试信息

在 template 中添加：

```vue
<div class="debug-info" style="position: fixed; top: 10px; left: 10px; background: white; padding: 10px;">
  <p>gameStarted: {{ gameStarted }}</p>
  <p>gameOver: {{ gameOver }}</p>
  <p>isPaused: {{ isPaused }}</p>
</div>
```

这样你就能实时看到状态变量的值！

---

## 📖 总结

### 关键要点：

1. **一个 template，多个状态**
   - 不是真的多个页面，是一个页面的不同显示状态

2. **v-if 是开关**
   - `v-if="!gameStarted"` → 游戏未开始时显示
   - `v-if="gameOver"` → 游戏结束时显示

3. **ref 变量是控制器**
   - 改变 `ref` 变量的值
   - Vue 自动更新页面显示

4. **position: absolute 是遮罩**
   - 画布一直在后面
   - 开始/结束页面像"弹窗"一样覆盖在上面

### 类比理解：

想象一个舞台剧：
- **舞台** = canvas（画布）
- **幕布** = 开始页面/结束页面
- **状态变量** = 导演的指令
- **v-if** = 控制幕布升降的机关

导演（你的代码）说"开始"，幕布升起（`gameStarted = true`），观众看到舞台。
导演说"结束"，幕布降下（`gameOver = true`），观众看到结束画面。

---

## 🎓 扩展阅读

想深入了解？可以学习：
- Vue 官方文档：[条件渲染](https://cn.vuejs.org/guide/essentials/conditional.html)
- Vue 官方文档：[响应式基础](https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html)
- 单页面应用（SPA）vs 多页面应用（MPA）的区别

---

## ❓ 常见问题

**Q: 为什么不用 Vue Router？**
A: Vue Router 适合有多个"真实页面"的应用（如：首页、关于页、联系页）。我们的游戏只是不同的**游戏状态**，用简单的 `v-if` 就够了。

**Q: 画布为什么不用 v-if？**
A: 因为画布需要一直存在来保持游戏状态。如果用 `v-if`，每次切换状态画布会被销毁和重建，游戏数据会丢失。

**Q: 可以同时显示多个"页面"吗？**
A: 可以！比如暂停时，游戏画布和暂停遮罩同时显示。只要条件都满足，多个 `v-if` 可以同时为 `true`。

---

希望这个教程能帮助你理解条件渲染的概念！🎉
